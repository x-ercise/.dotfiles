var gulp = require('gulp');
var gulpTsLint = require('gulp-tslint');
var gulpTypescript = require('gulp-typescript');
var sourcemaps = require('gulp-sourcemaps');
var path = require('path');
var fs = require('graceful-fs');
var child_process = require('child_process');
var ncp = require('ncp');
var mkdirp = require('mkdirp');
var rimraf = require('rimraf');
var os = require('os');
var gulpsequence = require('gulp-sequence');
var argv = require('yargs').argv;
var tslint = require('tslint');
var jeditor = require('gulp-json-editor');
var https = require('https');
var download = require('download');
var unzip = require('better-unzip');
var tar = require('tar');
var glob = require('glob');
var stringify = require('json-stable-stringify');
var { createHash } = require('./src/utils/createHash');
var lintSources = [
    'src',
    'test'
].map(function (tsPath) { return tsPath + '/**/*.ts'; });
var launcherTargetFramework = 'net461';
var buildConfiguration = argv.buildConfiguration !== undefined ? argv.buildConfiguration : 'Release';
var linuxPrereqScriptUri = 'https://raw.githubusercontent.com/MicrosoftDocs/live-share/master/scripts/linux-prereqs.sh';
var depsDir = path.join(__dirname, 'out', 'deps');
var linuxPrereqScriptOutPath = path.join(depsDir, 'linux-prereqs.sh');
var launcherSourceFolderWindows = path.join(__dirname, '..', 'launcher', 'win');
var launcherReleaseFolderWindows = path.join(__dirname, '..', '..', 'bin', buildConfiguration, 'Cascade.VSCode.Launcher', launcherTargetFramework, 'publish');
var launcherSourceFolderMac = path.join(__dirname, '..', 'launcher', 'osx');
var launcherReleaseFolderMac = path.join(launcherSourceFolderMac, 'build', buildConfiguration);
var launcherDestinationWindows = path.join(launcherSourceFolderWindows, 'npm');
var launcherDestinationMac = path.join(launcherSourceFolderMac, 'npm');
var agentSourceFolder = path.join(__dirname, '..', '..', 'src', 'Agent');
var agentReleaseFolder = path.join(__dirname, '..', '..', 'bin', buildConfiguration, 'Cascade.Agent');
var dotNetModulesDestination = path.join(__dirname, 'dotnet_modules');
var installLockFile = path.join(__dirname, 'install.Lock');
var codegenSourceFolder = path.join(__dirname, '..', '..', 'Tools', 'Cascade.TypescriptGenerator');
var contractsTargetDir = path.join(__dirname, 'src', 'contracts');
var adapterSourceFolder = path.join(__dirname, '..', '..', 'src', 'Debugger', 'VSCodeAdapter');
var hostAdapterSourceFolder = path.join(__dirname, '..', '..', 'src', 'Debugger', 'VSCodeHostAdapter');
var debuggerCommonSourceFolder = path.join(__dirname, '..', '..', 'src', 'Debugger', 'Common');
var adapterReleaseFolder = path.join(__dirname, '..', '..', 'bin', buildConfiguration, 'VSCodeAdapter');
var hostAdapterReleaseFolder = path.join(__dirname, '..', '..', 'bin', buildConfiguration, 'VSCodeHostAdapter');
var nugetPackagesDir = path.join(os.homedir(), '.nuget', 'packages');
var apiPackageDir = path.join(__dirname, 'src', 'api');
// This file is used to obtain the build version generated by the git-versioning package.
var buildVersionMetadataFile = path.join(__dirname, '..', '..', 'bin', 'obj', 'Cascade.Agent', buildConfiguration, 'netcoreapp2.1', 'vsls-agent.Version.cs');
var ridWindows = 'win7-x86';
var ridMac = 'osx.10.10-x64';
var ridLinux = 'linux-x64';
var targetFramework = "netcoreapp2.1";
var runtimeIds = [ridWindows, ridMac, ridLinux];
// empty rid means publish as portable.
var runtimeIdsToPublish = [ridWindows, ridMac, ridLinux, ''];
gulp.task('set-dev-mode', function () {
    switch (os.platform()) {
        case 'linux':
            runtimeIds = [ridLinux];
            runtimeIdsToPublish = [ridLinux], '';
            break;
        case 'darwin':
            runtimeIds = [ridMac];
            runtimeIdsToPublish = [ridMac, ''];
            break;
        case 'win32':
        default:
            runtimeIds = [ridWindows];
            runtimeIdsToPublish = [ridWindows, ''];
            break;
    }
    return;
});
gulp.task('generate-contracts', function () {
    return ensurePath(contractsTargetDir).then(() => {
        // Skip build when running as an online build task on Windows; the solution will have
        // been already built. (Building via `dotnet` there fails with signing issues.)
        // Build when running locally, to ensure incremental contract changes are picked up.
        var options = process.env.TF_BUILD && os.platform() === 'win32' ? '--no-restore --no-build' : '--no-restore';
        return executeCommand(codegenSourceFolder, 'dotnet run ' + options + ' -c ' + buildConfiguration + ' -f ' + targetFramework +
            ` -- "${contractsTargetDir}"`);
    });
});
gulp.task('contracts-restore', function () {
    return executeCommand(codegenSourceFolder, 'dotnet restore');
});
gulp.task('tslint', ['compile'], function () {
    var program = tslint.Linter.createProgram('./tslint.json');
    return gulp.src(lintSources, { base: '.' })
        .pipe(gulpTsLint({
        formatter: 'verbose',
        program: program
    }))
        .pipe(gulpTsLint.report());
});
gulp.task('copy-electron-sign-in-module-assets', function () {
    return new Promise(function (resolve, reject) {
        var electronSignInDestinationDir = path.join(__dirname, 'out', 'src', 'electronSignIn');
        return Promise.resolve()
            .then(function () { return ensurePath(electronSignInDestinationDir); })
            .then(function () { return copy(path.join(__dirname, 'src', 'electronSignIn', 'package.json'), path.join(electronSignInDestinationDir, 'package.json'), true); })
            .then(resolve, reject);
    });
});
gulp.task('compile', ['copy-electron-sign-in-module-assets'], function () {
    var tsProject = gulpTypescript.createProject('tsconfig.json');
    return tsProject.src()
        .pipe(sourcemaps.init())
        .pipe(tsProject())
        .once('error', function () {
        this.once('finish', () => process.exit(1));
    })
        .pipe(sourcemaps.write('.', { includeContent: false, sourceRoot: path.join(__dirname, 'out') }))
        .pipe(gulp.dest('out'));
});
gulp.task('copy-html-assets', function () {
    return new Promise(function (resolve, reject) {
        var welcomePageDestinationDir = path.join(__dirname, 'out', 'src', 'welcomePage');
        return Promise.resolve()
            .then(function () { return ensurePath(welcomePageDestinationDir); })
            .then(function () { return copy(path.join(__dirname, 'src', 'welcomePage', 'welcomePage.html'), path.join(welcomePageDestinationDir, 'welcomePage.html'), true); })
            .then(function () { return copy(path.join(__dirname, 'src', 'welcomePage', 'welcomePage.css'), path.join(welcomePageDestinationDir, 'welcomePage.css'), true); })
            .then(resolve, reject);
    });
});
gulp.task('agent-restore', function () {
    return executeCommand(agentSourceFolder, 'dotnet restore');
});
gulp.task('agent-publish', function () {
    return runtimeIdsToPublish.reduce(function (soFar, currentValue, currentIndex) {
        return soFar.then(function () {
            return executeCommand(agentSourceFolder, 'dotnet publish --no-restore -c ' + buildConfiguration + ' -f ' + targetFramework +
                (currentValue !== '' ? (' -r ' + currentValue) : ''));
        });
    }, Promise.resolve(void 0));
});
gulp.task('agent-binplace-ridspecific', ['agent-publish'], function () {
    return binplaceRidSpecificAssets(path.join(agentReleaseFolder, targetFramework), 'vsls-agent');
});
function binplaceRidSpecificAssets(sourceFolder, exeName) {
    return runtimeIds.reduce(function (sofar, currentValue, currentIndex) {
        return sofar.then(function () {
            return new Promise(function (resolve, reject) {
                var sourceDir = path.join(sourceFolder, currentValue, 'publish');
                var destinationDir = path.join(dotNetModulesDestination, 'runtimes', currentValue);
                var exeNameWithExt, hostfxr;
                var depsJson = exeName + '.deps.json';
                var runtimeConfigJson = exeName + '.runtimeconfig.json';
                if (currentValue == ridWindows) {
                    exeNameWithExt = exeName + '.exe';
                    hostfxr = 'hostfxr.dll';
                }
                else if (currentValue == ridMac) {
                    exeNameWithExt = exeName;
                    hostfxr = 'libhostfxr.dylib';
                }
                else if (currentValue == ridLinux) {
                    exeNameWithExt = exeName;
                    hostfxr = 'libhostfxr.so';
                }
                else {
                    throw "Unknown rid - " + currentValue;
                }
                console.log('Copying from ' + sourceDir + ' to ' + destinationDir);
                return Promise.resolve()
                    .then(function () { return ensurePath(destinationDir); })
                    .then(function () { return copy(path.join(sourceDir, exeNameWithExt), path.join(destinationDir, exeNameWithExt)); })
                    .then(function () { return copy(path.join(sourceDir, hostfxr), path.join(destinationDir, hostfxr)); })
                    .then(function () { return copy(path.join(sourceDir, depsJson), path.join(destinationDir, depsJson)); })
                    .then(function () { return copy(path.join(sourceDir, runtimeConfigJson), path.join(destinationDir, runtimeConfigJson)); })
                    .then(resolve, reject);
            });
        });
    }, Promise.resolve(void 0));
}
gulp.task('agent-binplace', ['agent-binplace-ridspecific'], function () {
    return new Promise(function (resolve, reject) {
        var source = path.join(agentReleaseFolder, targetFramework, 'publish');
        var destination = dotNetModulesDestination;
        console.log('Copying from ' + source + ' to ' + destination);
        return Promise.resolve()
            .then(function () { return ensurePath(destination); })
            .then(function () { return copy(source, destination); })
            .then(resolve, reject);
    });
});
gulp.task('adapter-restore', function () {
    return executeCommand(adapterSourceFolder, 'dotnet restore').
        then(executeCommand(debuggerCommonSourceFolder, 'dotnet restore'));
});
gulp.task('adapter-publish', function () {
    return runtimeIdsToPublish.reduce(function (soFar, currentValue, currentIndex) {
        return soFar.then(function () {
            return executeCommand(adapterSourceFolder, 'dotnet publish --no-restore -c ' + buildConfiguration + ' -f ' + targetFramework +
                (currentValue !== '' ? (' -r ' + currentValue) : ''));
        });
    }, Promise.resolve(void 0));
});
gulp.task('adapter-binplace-ridspecific', ['adapter-publish'], function () {
    return binplaceRidSpecificAssets(adapterReleaseFolder, 'Microsoft.Cascade.VSCodeAdapter');
});
gulp.task('adapter-binplace', ['adapter-binplace-ridspecific'], function () {
    return new Promise(function (resolve, reject) {
        var publishAdapter = path.join(adapterReleaseFolder, 'publish');
        var adapterDestination = dotNetModulesDestination;
        console.log('Copying from ' + publishAdapter + ' to ' + adapterDestination);
        return Promise.resolve()
            .then(function () { return ensurePath(adapterDestination); })
            .then(function () { return copy(publishAdapter, adapterDestination); })
            .then(resolve, reject);
    });
});
gulp.task('host-adapter-restore', function () {
    return executeCommand(debuggerCommonSourceFolder, 'dotnet restore')
        .then(executeCommand(hostAdapterSourceFolder, 'dotnet restore'));
});
gulp.task('host-adapter-publish', function () {
    return runtimeIdsToPublish.reduce(function (soFar, currentValue, currentIndex) {
        return soFar.then(function () {
            return executeCommand(hostAdapterSourceFolder, 'dotnet publish --no-restore -c ' + buildConfiguration + ' -f ' + targetFramework +
                (currentValue !== '' ? (' -r ' + currentValue) : ''));
        });
    }, Promise.resolve(void 0));
});
gulp.task('host-adapter-binplace-ridspecific', ['host-adapter-publish'], function () {
    return binplaceRidSpecificAssets(hostAdapterReleaseFolder, 'Microsoft.Cascade.VSCodeHostAdapter');
});
gulp.task('host-adapter-binplace', ['host-adapter-binplace-ridspecific'], function () {
    return new Promise(function (resolve, reject) {
        var publishHostAdapter = path.join(hostAdapterReleaseFolder, 'publish');
        var hostAdapterDestination = dotNetModulesDestination;
        console.log('Copying from ' + publishHostAdapter + ' to ' + hostAdapterDestination);
        return Promise.resolve()
            .then(function () { return ensurePath(hostAdapterDestination); })
            .then(function () { return copy(publishHostAdapter, hostAdapterDestination); })
            .then(resolve, reject);
    });
});
gulp.task('build-linuxprereq', function () {
    return new Promise(function (resolve, reject) {
        https.get(linuxPrereqScriptUri, function (res) {
            if (res.statusCode != 200) {
                console.log('Failed to get ' + linuxPrereqScriptUri + '. Status code: ' + res.statusCode);
                reject();
            }
            else {
                res.setEncoding('utf8');
                let rawData = '';
                res.on('data', (chunk) => { rawData += chunk; });
                res.on('end', () => {
                    console.log('Got ' + linuxPrereqScriptUri);
                    ensurePath(depsDir).then(() => {
                        fs.writeFileSync(linuxPrereqScriptOutPath, rawData, 'utf8');
                        console.log('Wrote to ' + linuxPrereqScriptOutPath);
                        resolve(linuxPrereqScriptOutPath);
                    });
                });
            }
        });
    });
});
gulp.task('build', gulpsequence('generate-contracts', ['compile', 'tslint', 'copy-html-assets']));
/* All restore tasks are called in parallel */
gulp.task('restore', gulpsequence(['contracts-restore', 'agent-restore', 'host-adapter-restore', 'adapter-restore']));
gulp.task('build-external', gulpsequence('restore', 'agent-binplace', 'host-adapter-binplace', 'adapter-binplace'));
gulp.task('release', gulpsequence(['clean-deps', 'clean-dotnet-modules'], ['build-external', 'build-linuxprereq'], 'build', 'update-version', 'manifest'));
/* Called by the CI server. */
gulp.task('release-no-restore', gulpsequence(['clean-deps', 'clean-dotnet-modules'], ['agent-binplace', 'build-linuxprereq'], 'build', 'host-adapter-binplace', 'adapter-binplace', 'update-version', 'manifest'));
gulp.task('default', ['release']);
gulp.task('release-dev', gulpsequence('set-dev-mode', 'release'));
/* Updates the package version, if necessary, not including the build number part of the version.
   This is invoked during every build. */
gulp.task('update-version', function () {
    updatePackageVersion(path.join(__dirname, 'package.json'), false);
    updatePackageVersion(path.join(apiPackageDir, 'package.json'), false);
    copyProtocolVersion();
});
/* Updates package version, if necessary, including the build number part of the version.
   Invoke this before publishing the extension package, but do not commit the modified package.json. */
gulp.task('update-build-version', function () {
    updatePackageVersion(path.join(__dirname, 'package.json'), true);
    updatePackageVersion(path.join(apiPackageDir, 'package.json'), true);
    copyProtocolVersion();
});
function updatePackageVersion(packageJsonFile, isReleaseBuild) {
    var version = getBuildVersion();
    var packageJson = JSON.parse(fs.readFileSync(packageJsonFile));
    var packageVersionParts = packageJson.version && packageJson.version.match(/(\d+)\.(\d+)\.(\d+)(-.+)?/);
    var buildVersionParts = version && version.match(/(\d+)\.(\d+)\.(\d+).(\d+)/);
    if (packageVersionParts && buildVersionParts) {
        var packageVersion = isReleaseBuild ?
            (buildVersionParts[1] + '.' +
                buildVersionParts[2] + '.' +
                buildVersionParts[3]) :
            (buildVersionParts[1] + '.' +
                (parseInt(buildVersionParts[2]) + 1) + '.0' +
                (packageVersionParts[4] || ''));
        if (packageJson.version !== packageVersion) {
            packageJson.version = packageVersion;
            fs.writeFileSync(packageJsonFile, JSON.stringify(packageJson, null, "  ") + '\n');
        }
    }
}
gulp.task('launcher-restore', function () {
    switch (os.platform()) {
        case 'win32':
            return executeCommand(launcherSourceFolderWindows, 'dotnet restore');
        default:
            return;
    }
});
gulp.task('launcher-build', ['launcher-restore'], function () {
    switch (os.platform()) {
        case 'win32':
            return executeCommand(launcherSourceFolderWindows, 'dotnet publish --no-restore -c ' + buildConfiguration + ' -f ' + launcherTargetFramework);
        case 'darwin':
            return executeCommand(launcherSourceFolderMac, 'xcodebuild build -configuration ' + buildConfiguration);
    }
});
gulp.task('launcher-binplace', ['launcher-build'], function () {
    switch (os.platform()) {
        case 'win32':
            return new Promise(function (resolve, reject) {
                var destination = path.join(launcherDestinationWindows);
                console.log('Copying from ' + launcherReleaseFolderWindows + ' to ' + destination);
                return Promise.resolve()
                    .then(function () { return ensurePath(destination); })
                    .then(function () { return copy(launcherReleaseFolderWindows, destination, true); })
                    .then(resolve, reject);
            });
        case 'darwin':
            return new Promise(function (resolve, reject) {
                var destination = path.join(launcherDestinationMac);
                console.log('Copying from ' + launcherReleaseFolderMac + ' to ' + destination);
                return Promise.resolve()
                    .then(function () { return ensurePath(destination); })
                    .then(function () { return copy(launcherReleaseFolderMac, destination, true); })
                    .then(resolve, reject);
            });
    }
});
gulp.task('clean-dotnet-modules', function () {
    return deletePath(dotNetModulesDestination)
        .then(function () { deletePath(installLockFile); });
});
gulp.task('clean-deps', function () {
    return deletePath(depsDir)
        .then(function () { deletePath('manifest.json'); });
});
async function createDownloadHash(runtimeDependencies) {
    const fileHashMap = {};
    await Promise.all(runtimeDependencies.map(async (dep) => {
        console.log(`Downloading ${dep.url}...`);
        const data = await download(dep.url, null, {
            followRedirect: true
        });
        const tempDir = fs.mkdtempSync('vsls');
        const compressionType = dep.url.endsWith('zip') ? 'zip' : 'tar.gz';
        const fileName = 'tmp.' + compressionType;
        const filePath = path.join(tempDir, '/', fileName);
        await fs.writeFile(filePath, data);
        console.log(`Decompressing ${filePath} (for ${dep.code})...`);
        switch (compressionType) {
            case 'zip': {
                await new Promise((resolve, reject) => {
                    fs.createReadStream(filePath)
                        .pipe(unzip.Extract({ path: tempDir }))
                        .on('close', resolve)
                        .on('error', reject);
                });
                break;
            }
            case 'tar.gz': {
                await tar.extract({
                    cwd: tempDir,
                    file: filePath
                }, [dep.packageRootPath]);
                break;
            }
            default:
                break;
        }
        fs.unlinkSync(filePath);
        const fileNames = await getAllFilesAsync(tempDir);
        fileHashMap[dep.code] = {};
        console.log(`Creating hash for ${dep.code}...`);
        await Promise.all(fileNames.map(async (fileName) => {
            if (!fileName.length) {
                return;
            }
            const hash = await createHash(path.join(tempDir, fileName));
            const normalizedFileName = fileName.replace(/\\/g, '/');
            fileHashMap[dep.code][normalizedFileName] = hash;
        }));
        await deletePath(tempDir);
    }));
    return fileHashMap;
}
async function getAllFilesAsync(dir) {
    return new Promise((resolve, reject) => {
        glob('**/*', {
            cwd: dir,
            nodir: true,
            absolute: false
        }, (err, matches) => {
            if (err) {
                return reject(err);
            }
            return resolve(matches);
        });
    });
}
gulp.task('external-manifest', async function () {
    const pkg = JSON.parse(fs.readFileSync(path.join(__dirname, 'package.json')));
    const { runtimeDependencies } = pkg;
    const downloadHash = await createDownloadHash(runtimeDependencies);
    return fs.writeFile('externalManifest.json', stringify(downloadHash, { space: '  ' }));
});
gulp.task('manifest', async function () {
    const vscePath = path.join(__dirname, 'node_modules', '.bin', 'vsce');
    const fileNames = child_process
        .execSync(`"${vscePath}" ls`, { cwd: __dirname })
        .toString()
        .split('\n');
    const fileHashMap = {};
    await Promise.all(fileNames.map(async (fileName) => {
        if (!fileName.length) {
            return;
        }
        const hash = await createHash(fileName);
        fileHashMap[fileName] = hash;
    }));
    return fs.writeFile('manifest.json', stringify(fileHashMap, { space: '  ' }));
});
gulp.task('pack', async function () {
    const vscePath = path.join(__dirname, 'node_modules', '.bin', 'vsce');
    return executeCommand(__dirname, `"${vscePath}" package`)
        // Also pack the API npm package, which requires copying over a couple files.
        .then(() => copy(path.join(__dirname, 'LICENSE.txt'), path.join(apiPackageDir, 'LICENSE.txt')))
        .then(() => copy(path.join(__dirname, 'out', 'src', 'api', 'liveShare.js'), path.join(apiPackageDir, 'vscode.js')))
        .then(() => copy(path.join(apiPackageDir, 'liveShare.ts'), path.join(apiPackageDir, 'vscode.ts')))
        .then(() => executeCommand('.', `npm pack "${apiPackageDir}"`))
        .then(() => deletePath(path.join(apiPackageDir, 'vscode.js')))
        .then(() => deletePath(path.join(apiPackageDir, 'vscode.ts')))
        .then(() => deletePath(path.join(apiPackageDir, 'LICENSE.txt')));
});
gulp.task('update-internal-settings', function () {
    switch (argv.target) {
        case 'insiders':
            return gulp.src('internalSettings.json')
                .pipe(jeditor({
                'serviceUri': 'https://insiders.liveshare.vsengsaas.visualstudio.com'
            }))
                .pipe(gulp.dest('.'));
            break;
        case 'production':
            return gulp.src('internalSettings.json')
                .pipe(jeditor({
                'serviceUri': 'https://prod.liveshare.vsengsaas.visualstudio.com/'
            }))
                .pipe(gulp.dest('.'));
            break;
        default:
            throw "Please specify a valid release target when updating the settings file.";
    }
});
function executeCommand(cwd, commandToExecute) {
    return new Promise(function (resolve, reject) {
        var process = child_process.exec(commandToExecute, { cwd: cwd }, (error, stdout, stderr) => {
            if (error) {
                console.error("Error: " + error);
            }
            stderr && console.log(stderr);
            stdout && console.log(stdout);
        });
        process.on("error", function (err) {
            console.log("Command failed: " + err);
            reject(err);
        });
        process.on("close", function (exitCode) {
            if (exitCode) {
                console.log("Command failed with exit code " + exitCode);
                reject(exitCode);
            }
            else {
                resolve();
            }
        });
    });
}
function deletePath(path) {
    return new Promise(function (resolve, reject) {
        rimraf(path, function (error) {
            error ? reject(error) : resolve();
        });
    });
}
function ensurePath(path) {
    return new Promise(function (resolve, reject) {
        mkdirp(path, function (err) {
            err ? reject(err) : resolve();
        });
    });
}
function copy(source, destination, clobber) {
    clobber = clobber || false;
    return new Promise(function (resolve, reject) {
        var options = { clobber: clobber, stopOnErr: true };
        ncp(source, destination, options, function (err) {
            err ? reject(err) : resolve();
        });
    });
}
function getBuildVersion() {
    var buildVersionMetadata = fs.readFileSync(buildVersionMetadataFile);
    var buildVersionMatch = /AssemblyFileVersionAttribute\("(\d+\.\d+\.\d+\.\d+)/
        .exec(buildVersionMetadata);
    if (!buildVersionMatch)
        throw new Error('Build version not found in file: ' + buildVersionMetadataFile);
    return buildVersionMatch[1];
}
/* Copies the protocol version from the version.json file at the root of the repo
   to a version.json file at the extension root. */
function copyProtocolVersion() {
    var versionJson = fs.readFileSync(path.join(__dirname, '../../version.json')).toString();
    versionJson = versionJson.replace(/(^| )\/\/.*$/gm, ''); // Strip double-slash comments
    var versionObject = JSON.parse(versionJson);
    versionObject = { protocolVersion: versionObject.protocolVersion };
    fs.writeFileSync(path.join(__dirname, 'version.json'), JSON.stringify(versionObject));
}

//# sourceMappingURL=gulpfile.js.map
